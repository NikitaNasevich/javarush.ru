# [task01](https://github.com/NikitaNasevich/javarush.ru/tree/main/level29/task01)

Рефакторинг в соответствии с Naming and Code Convention
Исправить код в соответствии с Naming and Code Convention (Shift+F6 для рефакторинга).


Requirements:
1. Переименуй константу defaultFileName в соответствии с Naming and Code Convention.
2. Переименуй метод getFileLoaded() в соответствии с Naming and Code Convention.
3. Переименуй метод DownloadFileContent() в соответствии с Naming and Code Convention.
4. Переименуй метод isexpectedline() в соответствии с Naming and Code Convention.
5. Переименуй параметр expectedline метода принимающего String в соответствии с Naming and Code Convention.

# [task02](https://github.com/NikitaNasevich/javarush.ru/tree/main/level29/task02)

Рефакторинг в соответствии с Naming and Code Convention 2
Исправить код в соответствии с Naming and Code Convention (Shift+F6 для рефакторинга).


Requirements:
1. Переименуй переменную Solution типа Solution в соответствии с Naming and Code Convention.
2. Переименуй переменную name_of_file_to_be_opened_by_notepad типа String в соответствии с Naming and Code Convention.
3. Переименуй переменную NOTEPAD типа Process в соответствии с Naming and Code Convention.
4. Переименуй метод getstartnotepadprocess() в соответствии с Naming and Code Convention.
5. Переименуй параметр FILE_NAME метода принимающего String в соответствии с Naming and Code Convention.
6. Переименуй переменную cmd_array типа String[] в соответствии с Naming and Code Convention.
7. Переименуй метод Getabsolutepathtodefaulttxtfile() в соответствии с Naming and Code Convention.
8. Переименуй переменную uRi типа URI в соответствии с Naming and Code Convention.

# [task03](https://github.com/NikitaNasevich/javarush.ru/tree/main/level29/task03)

И еще раз рефакторинг Ӏ Java Multithreading: 9 уровень, 5 лекция
1. Исправить код в соответствии с Naming and Code Convention (Shift+F6 для рефакторинга)
2. Просмотри методы класса ConcurrentMap.
3. В строке "String previousEntry = null;" у concurrentMap вызови метод, который вставит пару (randomInt, text) только для ключа, которого нет в concurrentMap.
(Вызванный метод должен возвращать предыдущее значение либо null для новой пары.)


Requirements:
1. Переименуй константу random в соответствии с Naming and Code Convention.
2. Объект, возвращаемый методом getRunnable(), должен быть экземпляром анонимного класса.
3. Метод run() внутри метода getRunnable() должен вызывать у concurrentMap метод, вставляющий пару (randomInt, text), если в concurrentMap еще нет пары со значением ключа randomInt.
4. Метод run() класса, возвращаемого методом getRunnable(), должен выводить текст на экран.

# [task04](https://github.com/NikitaNasevich/javarush.ru/tree/main/level29/task04)

Особенности автобоксинга

Исправь ошибку в методе getValueByIndex().

Читай доп. статью про особенности автобоксинга.


Requirements:
1. Метод getValueByIndex() должен возвращать объект типа Integer из массива array, если элемент с индексом index есть в массиве.
2. Метод getValueByIndex() должен возвращать объект типа Double, равный -1, если в массиве array нет элемента с индексом index.
3. Метод main() не изменять.
4. Программа должна вывести две строки: "-1.0, class java.lang.Double" и "3, class java.lang.Integer".

# [task05](https://github.com/NikitaNasevich/javarush.ru/tree/main/level29/task05)

Странные ошибки О_о
Исправь 2 ошибки:
1) возникновение исключения
2) подвисание
Сделай минимальные изменения.


Requirements:
1. Метод startCreatingMessages() должен без зависаний добавлять в messageQueue 100000 элементов.
2. Исправь ошибку в строке "messageQueue.drainTo(messageQueue, MAX_BATCH_SIZE);".
3. Метод main() не должен зависать.
4. Вывод программы должен показывать, что все сообщения из messageQueue были перенесены в fakeDataBase.

# [task06](https://github.com/NikitaNasevich/javarush.ru/tree/main/level29/task06)

Особенности автобоксинга - 2

Исправь ошибку реализации, приводящую к NullPointerException, в методе getValue().

Читай доп. статью про особенности автобоксинга.


Requirements:
1. Реализация метод getValue() должна использовать тернарный оператор.
2. Метод getValue() не должен кидать исключений при любых значениях параметров first и second.
3. Метод getValue() должен вернуть 100, если в него передать Boolean.TRUE и Boolean.TRUE.
4. Метод getValue() должен вернуть 200, если в него передать Boolean.FALSE и Boolean.TRUE.
5. Метод getValue() должен вернуть null, если в него передать Boolean.FALSE и Boolean.FALSE.

# [task07](https://github.com/NikitaNasevich/javarush.ru/tree/main/level29/task07)

Этот странный BigDecimal

Исправь ошибку реализации, приводящую к погрешности вычисления, в методе getValue().

Сигнатуру метода не менять. Округление не использовать.

Читай доп. статью про особенности автобоксинга.


Requirements:
1. Метод getValue() должен создавать два объекта типа BigDecimal.
2. Метод getValue() должен вызывать метод add() у созданного объекта BigDecimal.
3. Метод getValue() НЕ должен использовать метод round().
4. Метод getValue() должен возвращать результат без погрешности.

# [task08](https://github.com/NikitaNasevich/javarush.ru/tree/main/level29/task08)

Кеширование

В CacheComputeManager реализуй логику пустого метода.

Догадайся, что он должен делать по названию метода и по логике класса.


Requirements:
1. Метод createFutureTaskForNewArgumentThatHasToComputeValue() должен создавать и возвращать объект типа FutureTask.
2. В методе createFutureTaskForNewArgumentThatHasToComputeValue() должен создаваться объект анонимного класса, реализующего интерфейс Callable.
3. Внутри метода createFutureTaskForNewArgumentThatHasToComputeValue() должна встречаться строка "return computable.compute(arg);".
4. Программа должна выводить текст указанный в комментариях в классе Solution.

# [task09](https://github.com/NikitaNasevich/javarush.ru/tree/main/level29/task09)

Большая задача. Рефакторинг.


# [task10](https://github.com/NikitaNasevich/javarush.ru/tree/main/level29/task10)

Это архаичное слово "Биатлон"
Амиго, представляешь, в 21 веке существовал такой вид спорта - биатлон. Люди ездили на лыжах и стреляли на подготовленных площадках по мишеням. За одну серию стрельбы нужно было закрыть 5 мишеней. Стрельбы происходили как стоя, так и лежа, но не будем вдаваться в подробности. У лучших представителей рода человеческого средняя точность стрельбы достигала 90%, у крепких середнячков - 81,5%.
Я написал программу, которая создает соревнование, добавляет в него 30 спортсменов-биатлонистов. Каждому из них случайным образом выставляется точность (в диапазоне от 0,815 до 0,900). Штраф за каждый промах - плюс 20 секунд к результату. Еще у соревнования задается количество огневых рубежей - 4 и дистанция, которую биатлонисты должны преодолеть - 20 км.

Так же я создал контрольного спортсмена, у которого захардкожены показатели:
Скорость: 20 км/час;
Вероятность попадания: 0,900 (90%);
Количество промахов: 2 (Всего нужно попасть 20 раз. При точности 90 процентов ожидается 2 промаха);
Нужно проехать 20 км со скоростью 20 км/час. Необходимое время - 1 час, то есть 3600 секунд.
Время гонки (с учетом штрафных секунд): 3600 + 2 * 20 = 3640 секунд.
Я хочу определить, с какой скоростью должен ехать каждый спортсмен, при его случайном количестве промахов, чтобы результат в секундах был такой же, как и у контрольного спортсмена. В начале я вывожу результат контрольного спортсмена, потом все результаты. В конце я вывожу всех спортсменов, у которых время такое же, как и у контрольного спортсмена. У некоторых спортсменов за счет округления итоговое время отличается на доли секунды. Такие нам не нужны. У остальных время гонки ровно 3640 секунд, как и у контрольного спортсмена, но они не выводятся в секции "СПОРТСМЕНЫ С ТАКИМ ЖЕ ИТОГОВЫМ ВРЕМЕНЕМ, КАК У КОНТРОЛЬНОГО СПОРТСМЕНА:".

Твоя задача: сделать одно изменение в коде (добавить, удалить, или изменить один символ), чтобы исправить найденный баг.
Обрати внимание: все округления правильные, и новых добавлять не нужно!


Requirements:
1. Запрещено изменять типы данных констант.
2. Вывод на экран в секции "СПОРТСМЕНЫ С ТАКИМ ЖЕ ИТОГОВЫМ ВРЕМЕНЕМ, КАК У КОНТРОЛЬНОГО СПОРТСМЕНА:" должен содержать всех спортсменов, у которых такое же время, как и у контрольного спортсмена.
3. Сделай одно изменение в классе Game.
4. Класс Constants не изменяй.
5. Класс Solution не изменяй.
6. Класс Sportsman не изменяй.

# [task11](https://github.com/NikitaNasevich/javarush.ru/tree/main/level29/task11)

И еще раз рефакторинг Ӏ Java Multithreading: 9 уровень, 9 лекция
Задается целое число от 0 до 999 включительно случайным образом. Пользователь вводит с клавиатуры число.
Программа отвечает, введенное число больше или меньше загаданного. Если за 10 попыток пользователь программы угадывает число - программа выводит:
"Ты угадал!"
"Загаданное число: [number]"
иначе "Ты проиграл!".
Исправь одну ошибку, чтобы код выполнял описанные действия.


Requirements:
1. Если за 10 попыток не введено правильного числа - программа должна вывести на экран "Ты проиграл!".
2. Если введено неправильное число, флаг boolean flagWin не должен иметь значение true.
3. Не изменяй заголовки методов.
4. Нужно сделать одно изменение в правильном месте программы.

# [task12](https://github.com/NikitaNasevich/javarush.ru/tree/main/level29/task12)

Рефакторинг паттерна Chain of Responsibility
Есть программа, в которой реализована система логирования по принципу:
- если событие уровня FATAL - происходит звонок директору, отправляется СМС-сообщение CEO, выводится сообщение в консоль, происходит логирование в файл;
- если событие уровня ERROR - отправляется СМС-сообщение CEO, выводится сообщение в консоль, происходит логирование в файл;
- если событие уровня WARN - выводится сообщение в консоль, происходит логирование в файл;
- если событие уровня INFO - происходит логирование в файл.

В программе реализован паттерн "цепочка ответственности". Изучи его внимательно. В классах FileLogger, ConsoleLogger, SmsLogger, PhoneLogger есть много повторяющегося кода. Подними весь повторяющийся код в абстрактный класс AbstractLogger.
Подъемом в рефакторинге называется перенос полей, методов, конструкторов из всех наследников в одного общего предка. Из наследников, при этом, удаляется код, который перенесен в класс предка.

Логика работы программы не должна измениться.


Requirements:
1. Класс AbstractLogger должен быть публичным и абстрактным.
2. Класс AbstractLogger должен поддерживать интерфейс Logger.
3. Необходимо поднять поля level и next в класс AbstractLogger.
4. Необходимо поднять методы setNext(Logger) и inform(String, int) в класс AbstractLogger.
5. Вывод программы должен остаться неизменным.

# [task13](https://github.com/NikitaNasevich/javarush.ru/tree/main/level29/task13)

Замена рекурсии
В программе случайным образом генерируются два целых числа A и В в диапазоне от 0 (включая) до 1000 (не включая). Нужно вывести все целые числа от A до B включительно, в порядке возрастания, если A меньше B, или в порядке убывания в противном случае.

Задача реализована с использованием рекурсии.
Иногда в результате работы программы получаем Exception in thread "main" java.lang.StackOverflowError.

Твоя задача: перепиши код без использования рекурсии.
Метод recursion() переименуй на getAllNumbersBetween().


Requirements:
1. Метод recursion() необходимо переименовать на getAllNumbersBetween().
2. Ни в одном методе класса Solution не должно быть рекурсивных вызовов.
3. В конце строчки вывода последовательности чисел не должно быть пробела.
4. Логика работы программы должна остаться прежней.
5. Метод main() не изменять.
